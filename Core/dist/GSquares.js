var e={d:(s,i)=>{for(var t in i)e.o(i,t)&&!e.o(s,t)&&Object.defineProperty(s,t,{enumerable:!0,get:i[t]})},o:(e,s)=>Object.prototype.hasOwnProperty.call(e,s),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},s={};e.d(s,{bW:()=>r,Zt:()=>T,M6:()=>t,FA:()=>o,Us:()=>i});var i={};e.r(i),e.d(i,{Corner:()=>h,DoubleLine:()=>l,LBlock:()=>f,QuadLine:()=>n,SBlock:()=>p,SingleSquare:()=>a,Square:()=>u,TBlock:()=>d,TripleLine:()=>c});class t{constructor(){this.isOccupied=!1,this.tile=null}AddTile(e){this.isOccupied=!0,this.tile=e}}class r{constructor(e,s){this.sizeX=8,this.sizeY=8,this.sizeX=e,this.sizeY=s,this.squares=this.createSquares()}createSquares(){return Array.from({length:this.sizeX},(()=>Array.from({length:this.sizeY},(()=>new t))))}IsTileOccupied(e){return this.squares[e[0]][e[1]].isOccupied}CanTileBePlacedAtPos(e,s){for(const i of e.shape){const e=s[0]+i[0],t=s[1]+i[1];if(e>=this.sizeX||e<0||t>=this.sizeY||t<0||this.IsTileOccupied([e,t]))return!1}return!0}CanPlaceTile(e,s){return this.CanTileBePlacedAtPos(e,s)}PlaceTile(e,s){e.isPlaced?console.log(`Tile ${e} is already placed`):this.CanTileBePlacedAtPos(e,s)?e.shape.forEach((i=>{const t=s[0]+i[0],r=s[1]+i[1];console.log(t,r),this.squares[t][r].AddTile(e),e.isPlaced=!0})):console.log(`Tile ${e} cannot be placed at position ${s}`)}GetSquare(e,s){return this.squares[e][s]}PrintBoard(){let e="";for(let s=0;s<this.sizeY;s++){e="";for(let i=0;i<this.sizeX;i++)e+=" "+(this.squares[i][s].isOccupied?"X":"O");console.log(e)}}}class o{constructor(e){this.isPlaced=!1,this.shape=e}Rotate(){const e=[];this.shape.forEach((s=>{const i=s[0],t=-s[1],r=i;e.push([t,r])})),this.shape=e}Flip(){const e=[];this.shape.forEach((s=>{const i=-s[0],t=s[1];e.push([i,t])})),this.shape=e}}const a=()=>new o([[0,0]]),l=()=>new o([[0,0],[0,1]]),c=()=>new o([[0,0],[0,1],[0,2]]),n=()=>new o([[0,0],[0,1],[0,2],[0,3]]),h=()=>new o([[0,0],[0,1],[1,1]]),u=()=>new o([[0,0],[0,1],[1,1],[1,0]]),d=()=>new o([[0,0],[0,1],[1,0],[-1,0]]),p=()=>new o([[0,0],[0,1],[1,0],[1,-1]]),f=()=>new o([[0,0],[-1,0],[0,1],[0,2]]);class T{constructor(){this.sizeX=6,this.sizeY=6,this.nTilesBlocked=7,this.board=new r(this.sizeX,this.sizeY),this.tiles=[a(),l(),c(),n(),h(),u(),p(),d(),f()],this.AddBlockers()}AddBlockers(){let e,s,i=this.nTilesBlocked;for(;i>0;)e=b(0,this.sizeX),s=b(0,this.sizeY),this.board.GetSquare(e,s).isOccupied||(this.board.GetSquare(e,s).isOccupied=!0,i--)}IsBoardFull(){return!!this.board.squares.every((e=>e.every((e=>e.isOccupied))))}}function b(e,s){const i=Math.ceil(e),t=Math.floor(s);return Math.floor(Math.random()*(t-i)+i)}var z=s.bW,P=s.Zt,O=s.M6,S=s.FA,q=s.Us;export{z as Board,P as Game,O as Square,S as Tile,q as Tiles};